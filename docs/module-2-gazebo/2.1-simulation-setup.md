Markdown---
sidebar_position: 1
title: Gazebo and Unity: Building the Digital Twin
---

# Module 2: The Digital Twin (Weeks 6-7)

## Section 5: Simulation Environment Setup and Physics (Weeks 6-7 Part 1)

### Gazebo and Unity: Building the Digital Twin

#### 5.1 Introduction to Robot Simulation: Why Do We Use Digital Twins?

A **digital twin** is a high-fidelity virtual replica of a physical robot system that enables development, testing, and validation in a safe, accelerated, and cost-effective environment. In Physical AI development, digital twins serve as the primary platform for algorithm development before hardware deployment.

**Key Advantages of Simulation-Based Development:**

1. **Safety**: Test dangerous scenarios (falls, collisions, edge cases) without risk to hardware or humans
2. **Iteration Speed**: Deploy code changes in seconds rather than hours of hardware setup
3. **Parallelization**: Run thousands of test scenarios simultaneously across compute clusters
4. **Data Generation**: Synthesize labeled training data for perception and control algorithms
5. **Cost Efficiency**: Reduce hardware wear, eliminate consumables, minimize facility requirements
6. **Reproducibility**: Exact scenario replay for debugging and regression testing

**The Sim-to-Real Gap:**

The primary challenge in simulation-based robotics is transferring learned behaviors from simulation to physical hardware. Key discrepancies include:

- **Physics Fidelity**: Simplified contact models, friction approximations, actuator dynamics
- **Sensor Noise**: Perfect simulated sensors vs. noisy real-world measurements
- **Latency**: Zero-delay simulation vs. real sensor/actuator lag
- **Environment Variation**: Controlled simulation vs. unmodeled real-world complexity

```python
import numpy as np
import scipy.optimize

class SimToRealTransfer:
    """
    Techniques for bridging the simulation-reality gap
    """
    def __init__(self):
        self.domain_randomization = True
        self.system_identification = True
        self.default_sim_params = {'mass': 10.0, 'damping': 0.1} # Placeholder initialization
        
    def domain_randomization(self, sim_params):
        """
        Randomize simulation parameters during training
        to improve real-world robustness
        """
        randomized_params = {
            'mass': sim_params['mass'] * np.random.uniform(0.8, 1.2),
            'friction': np.random.uniform(0.3, 1.5),
            'joint_damping': sim_params['damping'] * np.random.uniform(0.5, 2.0),
            'sensor_noise_std': np.random.uniform(0.01, 0.05),
            'actuator_delay_ms': np.random.randint(5, 20)
        }
        return randomized_params
        
    def simulate_with_params(self, sim_params, measured_torques):
        # Dummy simulation function for system_identification example
        # In reality, this calls the physics engine
        return measured_torques * sim_params['damping'] * 0.1 

    def system_identification(self, real_robot_data):
        """
        Fit simulation parameters to match real robot behavior
        """
        # Collect real robot trajectories
        measured_states = real_robot_data['joint_positions']
        measured_torques = real_robot_data['joint_torques']
        
        # Optimize simulation parameters to minimize trajectory error
        def objective(sim_params):
            predicted_states = self.simulate_with_params(
                sim_params, 
                measured_torques
            )
            return np.linalg.norm(predicted_states - measured_states)
        
        optimal_params = scipy.optimize.minimize(
            objective,
            initial_guess=self.default_sim_params
        )
        
        return optimal_params
Digital Twin Workflow:┌────────────────────────────────────────────┐
│ 1. Robot Design (CAD → URDF/SDF)          │
└─────────────────┬──────────────────────────┘
                  │
┌─────────────────▼──────────────────────────┐
│ 2. Algorithm Development (Simulation)      │
│    - Control policies                      │
│    - Perception pipelines                  │
│    - Motion planning                       │
└─────────────────┬──────────────────────────┘
                  │
┌─────────────────▼──────────────────────────┐
│ 3. Sim-to-Real Transfer                    │
│    - Domain randomization                  │
│    - System identification                 │
│    - Progressive deployment                │
└─────────────────┬──────────────────────────┘
                  │
┌─────────────────▼──────────────────────────┐
│ 4. Hardware Validation                     │
│    - Closed-loop testing                   │
│    - Performance benchmarking              │
│    - Model refinement                      │
└────────────────────────────────────────────┘
5.2 Gazebo Simulation Environment Setup and Its ArchitectureGazebo is the industry-standard robot simulator for ROS 2 ecosystems. Gazebo Sim (formerly Ignition Gazebo) is the modern rewrite with improved performance and modularity.Core Components of Gazebo Architecture:Physics Engine: ODE, Bullet, DART, or Simbody for rigid body dynamicsRendering Engine: Ogre2 for 3D visualization and sensor simulationPlugin System: Extensible sensors, controllers, and world behaviorsTransport Layer: Ignition Transport for inter-process communicationScene Graph: Entity-Component-System (ECS) architectureInstallation and Workspace Setup:Bash# Install Gazebo Harmonic (recommended for ROS 2 Humble/Iron)
sudo apt-get install gz-harmonic

# Create ROS 2 workspace
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src

# Clone robot description package
git clone [https://github.com/example/humanoid_description.git](https://github.com/example/humanoid_description.git)

# Build workspace
cd ~/ros2_ws
colcon build --symlink-install

# Source workspace
source install/setup.bash
Gazebo Launch File Structure:Pythonfrom launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, ExecuteProcess
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    """
    Complete Gazebo simulation launch configuration
    """
    # Package paths
    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')
    pkg_robot_description = get_package_share_directory('humanoid_description')
    
    # World file path
    world_file = os.path.join(
        pkg_robot_description,
        'worlds',
        'warehouse.world'
    )
    
    # URDF/SDF model path
    robot_model = os.path.join(
        pkg_robot_description,
        'urdf',
        'humanoid_robot.urdf'
    )
    
    # Launch Gazebo server (physics simulation)
    gazebo_server = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(pkg_gazebo_ros, 'launch', 'gzserver.launch.py')
        ),
        launch_arguments={
            'world': world_file,
            'verbose': 'true',
            'physics': 'ode',  # Physics engine selection
            'extra_gazebo_args': '--ros-args --log-level warn'
        }.items()
    )
    
    # Launch Gazebo client (GUI)
    gazebo_client = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(pkg_gazebo_ros, 'launch', 'gzclient.launch.py')
        )
    )
    
    # Spawn robot into simulation
    spawn_robot = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-entity', 'humanoid_robot',
            '-file', robot_model,
            '-x', '0.0',
            '-y', '0.0',
            '-z', '1.0',  # Spawn 1m above ground
            '-robot_namespace', '/robot'
        ],
        output='screen'
    )
    
    # Robot state publisher (TF tree)
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[{'robot_description': open(robot_model).read()}],
        output='screen'
    )
    
    return LaunchDescription([
        gazebo_server,
        gazebo_client,
        robot_state_publisher,
        spawn_robot
    ])
Gazebo Plugin System:Plugins extend Gazebo functionality for custom sensors and controllers:XML<gazebo>
  <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
    <robotNamespace>/robot</robotNamespace>
    <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>
    <legacyModeNS>true</legacyModeNS>
  </plugin>
</gazebo>

<gazebo reference="base_link">
  <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">
    <topicName>/imu/data</topicName>
    <updateRateHZ>100.0</updateRateHZ>
    <gaussianNoise>0.01</gaussianNoise>
    <frameName>imu_link</frameName>
  </plugin>
</gazebo>
5.3 Physics Engine: Simulating Gravity, Collisions, and Rigid Body DynamicsGazebo supports multiple physics engines, each with different trade-offs:Physics EngineSpeedAccuracyContact StabilityUse CaseODEFastModerateGoodGeneral purposeBulletVery FastModerateModerateLarge scenesDARTModerateHighExcellentHumanoids, manipulationSimbodySlowVery HighExcellentBiomechanicsPhysics Configuration:XML<?xml version="1.0" ?>
<sdf version="1.6">
  <world name="warehouse">
    
    <physics name="default_physics" default="true" type="ode">
      <max_step_size>0.001</max_step_size>  <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000.0</real_time_update_rate>
      
      <ode>
        <solver>
          <type>quick</type>  <iters>50</iters>   <sor>1.3</sor>      </solver>
        <constraints>
          <cfm>0.0</cfm>      <erp>0.2</erp>      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>
    
    <gravity>0 0 -9.81</gravity>
    
    <magnetic_field>6e-06 2.3e-05 -4.2e-05</magnetic_field>
    
    <atmosphere type="adiabatic"/>
    
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>1.0</mu>    <mu2>1.0</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
      </link>
    </model>
    
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <direction>-0.5 0.1 -0.9</direction>
    </light>
    
  </world>
</sdf>
Rigid Body Dynamics Implementation:Pythonclass RigidBodySimulator:
    """
    Simplified physics engine for educational purposes
    Actual Gazebo uses highly optimized C++ implementations
    """
    def __init__(self, timestep=0.001):
        self.dt = timestep
        self.gravity = np.array([0, 0, -9.81])
        
    def simulate_rigid_body(self, body_state, applied_forces):
        """
        Integrate Newton-Euler equations for a single rigid body
        """
        # Extract state variables
        position = body_state['position']
        orientation = body_state['orientation']  # Quaternion
        linear_velocity = body_state['linear_velocity']
        angular_velocity = body_state['angular_velocity']
        
        mass = body_state['mass']
        inertia_tensor = body_state['inertia_tensor']
        
        # Compute net force (including gravity)
        net_force = applied_forces['force'] + mass * self.gravity
        
        # Linear dynamics: F = ma
        linear_acceleration = net_force / mass
        linear_velocity += linear_acceleration * self.dt
        position += linear_velocity * self.dt
        
        # Angular dynamics: τ = Iα + ω × (Iω)
        torque = applied_forces['torque']
        angular_acceleration = np.linalg.solve(
            inertia_tensor,
            torque - np.cross(angular_velocity, inertia_tensor @ angular_velocity)
        )
        angular_velocity += angular_acceleration * self.dt
        
        # Update orientation (quaternion integration)
        orientation = self.integrate_quaternion(
            orientation,
            angular_velocity,
            self.dt
        )
        
        return {
            'position': position,
            'orientation': orientation,
            'linear_velocity': linear_velocity,
            'angular_velocity': angular_velocity
        }
Collision Detection and Response (COMPLETED CODE):Pythonclass CollisionHandler:
    def __init__(self, restitution=0.5, friction=0.8):
        self.e = restitution  # Coefficient of restitution (bounciness)
        self.mu = friction    # Friction coefficient
        
    def resolve_collision(self, body_a, body_b, contact_point, contact_normal):
        """
        Impulse-based collision response between two bodies
        """
        # Relative velocity at contact point
        vel_a = body_a.get_velocity_at_point(contact_point)
        vel_b = body_b.get_velocity_at_point(contact_point)
        relative_velocity = vel_a - vel_b
        
        # Velocity along normal direction
        vel_normal = np.dot(relative_velocity, contact_normal)
        
        # Objects are separating, no collision response needed
        if vel_normal > 0:
            return
        
        # Compute collision impulse magnitude (j)
        # Note: Inverse inertia tensors and contact geometry factors are typically included here
        j = -(1 + self.e) * vel_normal
        j /= (1/body_a.mass + 1/body_b.mass) # Simplified mass calculation
        
        # Apply impulse along normal
        impulse = j * contact_normal
        body_a.linear_velocity += impulse / body_a.mass
        body_b.linear_velocity -= impulse / body_b.mass
        
        # Friction impulse (tangential)
        vel_tangent = relative_velocity - vel_normal * contact_normal
        if np.linalg.norm(vel_tangent) > 1e-6:
            friction_direction = vel_tangent / np.linalg.norm(vel_tangent)
            # Frictional impulse calculation (Coulomb friction model)
            friction_impulse_mag = min(self.mu * j, np.linalg.norm(vel_tangent))
            
            friction_impulse = friction_impulse_mag * friction_direction

            body_a.linear_velocity -= friction_impulse / body_a.mass
            body_b.linear_velocity += friction_impulse / body_b.mass
5.4 Using URDF/SDF in Gazebo: Loading the Robot ModelRobot models in Gazebo are defined using either URDF (Unified Robot Description Format) or SDF (Simulation Description Format). URDF is ROS-native and simpler, while SDF is more expressive and Gazebo-native.FeatureURDFSDFEcosystemROS-centricGazebo-centricClosed LoopsNoYesMultiple ModelsNoYes (in one file)SyntaxXMLXMLPluginsLimitedExtensiveLoading Robot Model into Gazebo:Pythonimport rclpy
from rclpy.node import Node
from gazebo_msgs.srv import SpawnEntity
from ament_index_python.packages import get_package_share_directory
import os

class RobotSpawner(Node):
    def __init__(self):
        super().__init__('robot_spawner')
        
        # Create service client for spawning entities
        self.spawn_client = self.create_client(
            SpawnEntity,
            '/spawn_entity'
        )
        
        while not self.spawn_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for spawn_entity service...')
        
        self.spawn_robot()
        
    def spawn_robot(self):
        """
        Load URDF and spawn robot in Gazebo
        """
        # Read URDF file
        pkg_path = get_package_share_directory('humanoid_description')
        urdf_file = os.path.join(pkg_path, 'urdf', 'humanoid_robot.urdf') # Complete path
        
        with open(urdf_file, 'r') as f:
            robot_xml = f.read()

        # Create SpawnEntity request
        request = SpawnEntity.Request()
        request.name = 'humanoid_robot'
        request.xml = robot_xml
        request.robot_namespace = '/robot'
        request.initial_pose.position.x = 0.0
        request.initial_pose.position.y = 0.0
        request.initial_pose.position.z = 1.0 # Spawn 1m above ground

        # Send request to Gazebo service
        future = self.spawn_client.call_async(request)
        rclpy.spin_until_future_complete(self, future)
        
        if future.result() is not None and future.result().success:
            self.get_logger().info('Humanoid robot successfully spawned!')
        else:
            self.get_logger().error(f'Failed to spawn robot: {future.result().status_message}')

# ---
#### **Key Concept Summary**

**Digital Twins** are essential for safe, cost-effective, and accelerated robotics development, though they must address the **Sim-to-Real Gap** through techniques like **Domain Randomization** and **System Identification**. **Gazebo** (Ignition Sim) is the standard ROS 2 simulator, relying on modular architecture (Physics Engine, Rendering Engine, Plugin System). The simulation is launched using **Python Launch Files** and controlled via ROS 2 plugins defined within the robot's URDF/SDF. **SDF** is the more expressive, Gazebo-native format, supporting features like closed kinematic loops and environmental elements not present in URDF.