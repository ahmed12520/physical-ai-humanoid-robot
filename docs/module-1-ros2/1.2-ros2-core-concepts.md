
## Section 2: ROS 2 Architecture Fundamentals (Weeks 3-5 Part 1)

### ROS 2 Core Concepts: Nodes, Topics, and Services

#### 2.1 What is ROS 2? The Robotic Middleware

The Robot Operating System 2 (ROS 2) is a middleware framework designed for distributed robotic systems. Unlike ROS 1, which was built for research environments, ROS 2 is engineered for production deployments with real-time constraints, security, and multi-robot systems.

**Key Architectural Improvements in ROS 2:**

- **DDS (Data Distribution Service)**: Industry-standard middleware replacing custom TCPROS protocol
- **Real-Time Capable**: Deterministic execution with deadline/lifespan QoS policies
- **Security Built-In**: DDS-Security with encryption and authentication
- **Multi-Platform**: Native support for Linux, Windows, macOS, and embedded systems
- **Language Agnostic**: Official support for C++, Python, with community bindings for Rust, Java, C#

**ROS 2 vs Traditional Robotics Architectures:**

```python
# Traditional monolithic robotics code
class MonolithicRobotController:
    def __init__(self):
        self.sensors = initialize_all_sensors()
        self.actuators = initialize_all_actuators()
        self.state_machine = StateMachine()
    
    def run(self):
        """
        Single-threaded control loop with tight coupling
        All components must run on same machine/process
        """
        while True:
            sensor_data = self.sensors.read()
            decision = self.state_machine.update(sensor_data)
            self.actuators.command(decision)
            time.sleep(0.01)  # 100Hz loop

# ROS 2 distributed architecture
# Each component is an independent node that can run anywhere
# Nodes communicate through typed messages over DDS

# Node 1: Sensor driver (can run on sensor's embedded computer)
class LidarDriverNode(rclpy.node.Node):
    def __init__(self):
        super().__init__('lidar_driver')
        self.publisher = self.create_publisher(
            LaserScan, 
            '/scan', 
            10
        )
        
# Node 2: Perception (can run on GPU workstation)
class PerceptionNode(rclpy.node.Node):
    def __init__(self):
        super().__init__('perception')
        self.subscription = self.create_subscription(
            LaserScan,
            '/scan',
            self.scan_callback,
            10
        )
        
# Node 3: Control (must run on real-time controller)
class ControlNode(rclpy.node.Node):
    def __init__(self):
        super().__init__('controller')
        # Subscribe to multiple inputs
        # Publish control commands
```

**The ROS 2 Middleware Abstraction:**

ROS 2 provides a hardware-agnostic abstraction layer that enables:
- Swapping sensors without changing application code
- Running the same code in simulation and on hardware
- Distributing computation across heterogeneous hardware
- Recording and replaying data for debugging

#### 2.2 The ROS 2 Graph: Understanding Nodes

A ROS 2 system is represented as a computational graph where **nodes** are vertices and **communication channels** are edges. Each node is an independent executable process with a specific responsibility.

**Node Design Principles:**

1. **Single Responsibility**: Each node should perform one well-defined task
2. **Loose Coupling**: Nodes communicate only through messages, not shared memory
3. **Location Transparency**: Nodes don't know where other nodes are running
4. **Hot-Swappable**: Nodes can be started/stopped without system restart

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy

class MinimalNode(Node):
    """
    Anatomy of a ROS 2 node in Python
    """
    def __init__(self):
        # Initialize node with unique name in the ROS 2 graph
        super().__init__('minimal_node')
        
        # Declare node parameters (runtime configuration)
        self.declare_parameter('update_rate_hz', 10.0)
        self.declare_parameter('debug_mode', False)
        
        # Read parameters
        self.rate = self.get_parameter('update_rate_hz').value
        self.debug = self.get_parameter('debug_mode').value
        
        # Create timer for periodic callbacks
        self.timer = self.create_timer(
            1.0 / self.rate,  # Period in seconds
            self.timer_callback
        )
        
        # Logging at different severity levels
        self.get_logger().info(f'Node initialized at {self.rate} Hz')
        
    def timer_callback(self):
        """
        Periodic callback executed by ROS 2 executor
        """
        if self.debug:
            self.get_logger().debug('Timer callback executed')
            
def main(args=None):
    # Initialize ROS 2 Python client library
    rclpy.init(args=args)
    
    # Create node instance
    node = MinimalNode()
    
    # Spin node (blocks until shutdown)
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**ROS 2 Graph Introspection:**

```bash
# List all active nodes in the system
ros2 node list

# Show detailed information about a node
ros2 node info /minimal_node

# Graph visualization
ros2 run rqt_graph rqt_graph

# Parameter manipulation
ros2 param list /minimal_node
ros2 param get /minimal_node update_rate_hz
ros2 param set /minimal_node debug_mode true
```

#### 2.3 Asynchronous Communication: Topics (Publishers/Subscribers)

**Topics** implement the publish-subscribe pattern for streaming data communication. This is the primary mechanism for sensor data flow and continuous state updates.

**Topic Communication Characteristics:**

- **Many-to-Many**: Multiple publishers and subscribers per topic
- **Asynchronous**: No blocking, fire-and-forget semantics
- **Typed**: Messages have defined schemas (`.msg` files)
- **QoS Configurable**: Reliability, durability, lifespan policies

```python
from rclpy.node import Node
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Twist
import numpy as np

class RobotStatePublisher(Node):
    """
    Publisher node: Sends robot joint states at 100 Hz
    """
    def __init__(self):
        super().__init__('robot_state_publisher')
        
        # Define QoS profile for sensor data
        sensor_qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,  # Don't wait for acks
            durability=DurabilityPolicy.VOLATILE,       # Don't store history
            depth=10                                     # Message queue size
        )
        
        # Create publisher
        self.joint_state_pub = self.create_publisher(
            JointState,
            '/joint_states',
            sensor_qos
        )
        
        # Publish at 100 Hz
        self.timer = self.create_timer(0.01, self.publish_joint_states)
        
        # Simulated robot state
        self.joint_names = ['shoulder', 'elbow', 'wrist']
        self.joint_positions = [0.0, 0.0, 0.0]
        
    def publish_joint_states(self):
        """
        Publish current joint angles
        """
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'base_link'
        msg.name = self.joint_names
        msg.position = self.joint_positions
        msg.velocity = [0.0] * len(self.joint_names)  # Placeholder
        msg.effort = [0.0] * len(self.joint_names)    # Torques
        
        self.joint_state_pub.publish(msg)
        
        # Simulate motion
        self.joint_positions[0] += 0.01

class VelocityCommandSubscriber(Node):
    """
    Subscriber node: Receives velocity commands for mobile base
    """
    def __init__(self):
        super().__init__('velocity_command_subscriber')
        
        # Define QoS for control commands
        control_qos = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,  # Guaranteed delivery
            durability=DurabilityPolicy.TRANSIENT_LOCAL,  # Late-joiners get last msg
            depth=1
        )
        
        # Create subscription
        self.velocity_sub = self.create_subscription(
            Twist,
            '/cmd_vel',
            self.velocity_callback,
            control_qos
        )
        
        self.last_command_time = self.get_clock().now()
        
    def velocity_callback(self, msg: Twist):
        """
        Called whenever new velocity command arrives
        """
        linear_vel = msg.linear.x
        angular_vel = msg.angular.z
        
        self.get_logger().info(
            f'Received: linear={linear_vel:.2f} m/s, '
            f'angular={angular_vel:.2f} rad/s'
        )
        
        # Watchdog: Check command freshness
        self.last_command_time = self.get_clock().now()
        
        # Execute motion command on robot
        self.execute_velocity_command(linear_vel, angular_vel)
        
    def execute_velocity_command(self, linear, angular):
        """
        Send to low-level motor controllers
        """
        pass  # Hardware-specific implementation
```

**Message Type Definition:**

```python
# Example: Create custom message type
# File: robot_interfaces/msg/RobotStatus.msg

std_msgs/Header header
string robot_id
float64 battery_percentage
uint8 operating_mode
geometry_msgs/Pose current_pose
bool[] joint_limits_hit

# Constants
uint8 MODE_IDLE = 0
uint8 MODE_MOVING = 1
uint8 MODE_ERROR = 2
```

**Topic Communication Patterns:**

```python
class DataFlowPatterns(Node):
    def __init__(self):
        super().__init__('data_flow_patterns')
        
        # Pattern 1: Sensor fusion (many publishers → one subscriber)
        self.create_subscription(LaserScan, '/lidar', self.lidar_cb, 10)
        self.create_subscription(Image, '/camera', self.camera_cb, 10)
        self.create_subscription(Imu, '/imu', self.imu_cb, 10)
        
        # Pattern 2: Broadcast (one publisher → many subscribers)
        self.clock_pub = self.create_publisher(Clock, '/clock', 10)
        
        # Pattern 3: Monitoring (one publisher → logging + visualization + control)
        self.status_pub = self.create_publisher(
            RobotStatus, 
            '/robot_status', 
            10
        )
```

#### 2.4 Synchronous Communication: Services (Client/Server)

**Services** implement request-response communication for infrequent, transactional interactions. Unlike topics, services block until a response is received.

**Service Use Cases:**

- Changing robot operating modes
- Requesting computation results (IK, path planning)
- Triggering one-time actions (homing, calibration)
- Configuration queries

```python
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
from geometry_msgs.msg import Pose
from custom_interfaces.srv import ComputeIK  # Custom service type

class IKServiceServer(Node):
    """
    Service server: Computes inverse kinematics on request
    """
    def __init__(self):
        super().__init__('ik_service_server')
        
        # Create service
        self.ik_service = self.create_service(
            ComputeIK,
            '/compute_inverse_kinematics',
            self.compute_ik_callback
        )
        
        self.get_logger().info('IK service ready')
        
    def compute_ik_callback(self, request, response):
        """
        Service callback: request → processing → response
        """
        target_pose = request.target_pose
        initial_guess = request.initial_joint_angles
        
        self.get_logger().info(
            f'IK request for position: '
            f'[{target_pose.position.x}, '
            f'{target_pose.position.y}, '
            f'{target_pose.position.z}]'
        )
        
        # Perform IK computation (simplified)
        joint_solution = self.solve_ik(target_pose, initial_guess)
        
        # Populate response
        response.joint_angles = joint_solution
        response.success = True if joint_solution else False
        response.error_message = '' if response.success else 'No IK solution'
        
        return response
    
    def solve_ik(self, pose, initial):
        """
        Actual IK solver (would use KDL, MoveIt, or custom solver)
        """
        # Placeholder for numeric IK solver
        return [0.1, 0.5, -0.3, 1.2, 0.0, 0.8]

class IKServiceClient(Node):
    """
    Service client: Requests IK solutions when needed
    """
    def __init__(self):
        super().__init__('ik_service_client')
        
        # Create client
        self.ik_client = self.create_client(
            ComputeIK,
            '/compute_inverse_kinematics'
        )
        
        # Wait for service to become available
        while not self.ik_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for IK service...')
            
    def request_ik_solution(self, target_pose):
        """
        Synchronous service call
        """
        request = ComputeIK.Request()
        request.target_pose = target_pose
        request.initial_joint_angles = [0.0] * 6
        
        # Call service (blocks until response)
        future = self.ik_client.call_async(request)
        rclpy.spin_until_future_complete(self, future)
        
        response = future.result()
        
        if response.success:
            self.get_logger().info(
                f'IK solution: {response.joint_angles}'
            )
            return response.joint_angles
        else:
            self.get_logger().error(
                f'IK failed: {response.error_message}'
            )
            return None
```

**Service Type